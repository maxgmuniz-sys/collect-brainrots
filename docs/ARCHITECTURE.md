# ARCHITECTURE.md -- Collect Brainrot's Code Architecture

> **Purpose:** This document describes the complete code architecture for "Collect Brainrot's" so that any developer or AI agent can understand the entire codebase structure, data flow, and module contracts without reading actual source code.

---

## Table of Contents

1. [Technology Stack](#1-technology-stack)
2. [Project File Tree](#2-project-file-tree)
3. [Rojo Mapping](#3-rojo-mapping)
4. [Module Dependency Graph](#4-module-dependency-graph)
5. [Service Boot Order](#5-service-boot-order)
6. [RemoteEvent/RemoteFunction Contracts](#6-remoteeventremotefunction-contracts)
7. [PlayerData Schema](#7-playerdata-schema)
8. [BrainrotInstance Type](#8-brainrotinstance-type)
9. [How Phases Plug In](#9-how-phases-plug-in)
10. [Data Flow Diagrams](#10-data-flow-diagrams)

---

## 1. Technology Stack

| Tool / Library | Version | Purpose |
|---|---|---|
| **Rojo** | 7.7.0-rc.1 | Syncs the filesystem project tree into Roblox Studio. Developers edit `.luau` files on disk; Rojo live-syncs changes into the Studio DataModel. |
| **Aftman** | latest | Toolchain manager. Installs and pins the exact versions of Rojo and Wally so every contributor uses the same binaries. Configured via `aftman.toml` at the repo root. |
| **Wally** | latest | Package manager for Roblox. Reads `wally.toml`, resolves dependencies, and downloads packages into the `Packages/` directory. |
| **ProfileStore** | via Wally | DataStore wrapper that handles session-locking, auto-saving, and data migration. Used by `DataService` for all player persistence. |
| **Luau** | Roblox built-in | Roblox's typed scripting language (superset of Lua 5.1). All game logic is written in `.luau` files with type annotations. |

### Local Development Workflow

```
aftman install          -- install Rojo + Wally at pinned versions
wally install           -- pull packages into Packages/
rojo build -o "collect-brainrots.rbxlx"   -- one-time build
rojo serve              -- live-sync to Studio
```

---

## 2. Project File Tree

Below is the complete file tree. Every file is listed with a description of its responsibility.

```
collect-brainrots/
|
+-- default.project.json
+-- wally.toml
+-- wally.lock
+-- aftman.toml
+-- .gitignore
+-- README.md
|
+-- Packages/                         (auto-generated by Wally, gitignored)
|
+-- docs/
|   +-- GAME_DESIGN.md
|   +-- ARCHITECTURE.md               (this file)
|   +-- PROGRESS.md
|   +-- AGENT_WORKFLOW.md
|   +-- phases/
|       +-- PHASE_0.md
|       +-- PHASE_1.md
|       +-- PHASE_2.md
|       +-- PHASE_3.md
|       +-- PHASE_4.md
|       +-- PHASE_5.md
|       +-- PHASE_6.md
|       +-- PHASE_7.md
|       +-- PHASE_8.md
|       +-- PHASE_9.md
|
+-- src/
    +-- shared/                       -> ReplicatedStorage/Shared
    |   +-- Config/
    |   |   +-- Brainrots.luau
    |   |   +-- Foods.luau
    |   |   +-- Mutations.luau
    |   |   +-- Sizes.luau
    |   |   +-- Weather.luau
    |   +-- Types.luau
    |   +-- Utils.luau
    |
    +-- server/                       -> ServerScriptService/Server
    |   +-- init.server.luau
    |   +-- Services/
    |   |   +-- DataService.luau
    |   |   +-- FoodService.luau
    |   |   +-- BaseService.luau
    |   |   +-- EarningsService.luau
    |   |   +-- WeatherService.luau
    |   |   +-- IndexService.luau
    |   |   +-- SellService.luau
    |   |   +-- GiftService.luau
    |   |   +-- LeaderboardService.luau
    |   +-- Remotes/
    |       +-- init.luau
    |
    +-- client/                       -> StarterPlayer/StarterPlayerScripts/Client
        +-- init.client.luau
        +-- Controllers/
            +-- FoodStoreUI.luau
            +-- MoneyUI.luau
            +-- BaseUI.luau
            +-- IndexUI.luau
            +-- SellUI.luau
            +-- WeatherUI.luau
            +-- LeaderboardUI.luau
            +-- TutorialUI.luau
```

### File-by-File Descriptions

#### Root Files

| File | Description |
|---|---|
| `default.project.json` | Rojo project configuration. Defines the mapping from filesystem directories to Roblox DataModel containers (ReplicatedStorage, ServerScriptService, StarterPlayerScripts). Also declares Workspace properties (Baseplate), Lighting, and SoundService settings. |
| `wally.toml` | Wally package manifest. Declares the project's package identity and its dependencies (currently ProfileStore). Running `wally install` reads this file and populates `Packages/`. |
| `wally.lock` | Auto-generated lockfile that pins exact resolved dependency versions. Committed to version control so every developer gets identical packages. |
| `aftman.toml` | Aftman toolchain manifest. Pins exact versions of Rojo (7.7.0-rc.1) and Wally so all contributors use identical tool binaries. |
| `.gitignore` | Excludes the `.rbxlx` place file, Studio lock files, `sourcemap.json`, and the `Packages/` directory from version control. |
| `README.md` | Basic getting-started instructions generated by `rojo init`. Shows how to build and serve the project. |

#### Packages/

Auto-generated directory produced by `wally install`. Contains downloaded Wally dependencies (ProfileStore and any transitive dependencies). This directory is gitignored; CI and contributors regenerate it from `wally.toml` / `wally.lock`.

#### docs/

| File | Description |
|---|---|
| `GAME_DESIGN.md` | Complete game design document covering all gameplay systems, mechanics, economy, brainrot data tables, rarity weights, mutation rules, and phase-by-phase feature breakdown. The single source of truth for "what the game does." |
| `ARCHITECTURE.md` | This file. Complete code architecture reference. Describes every module, its dependencies, data schemas, remote contracts, boot order, and data flows. The single source of truth for "how the code is structured." |
| `PROGRESS.md` | Tracks implementation progress. Lists which phases/features are complete, in progress, or not started. Updated after each phase is finished. |
| `AGENT_WORKFLOW.md` | Instructions for AI agents working on this codebase. Describes the expected workflow: read docs first, check PROGRESS.md, implement the next incomplete phase, test, update PROGRESS.md. |
| `phases/PHASE_0.md` through `phases/PHASE_9.md` | Per-phase implementation guides. Each file contains the detailed tasks, acceptance criteria, and implementation notes for that phase. An AI agent reads the relevant phase doc, implements the tasks, and marks them complete. |

#### src/shared/ (ReplicatedStorage/Shared)

These modules are accessible to both server and client code.

| File | Description |
|---|---|
| `Config/Brainrots.luau` | Defines the master table of all 25 brainrots. Each entry contains the brainrot's name, rarity tier, base earnings per second, model asset ID, description text, and any special properties. This is the authoritative data source for brainrot stats. |
| `Config/Foods.luau` | Defines the food tier table. Each food tier has a name, cost, rarity weight overrides (which brainrot rarities can be rolled from that tier), and an icon asset ID. Higher-cost foods give better odds at rarer brainrots. |
| `Config/Mutations.luau` | Defines both base mutations (Gold, Diamond, Rainbow) and weather-induced mutations (Soaked, Frozen, Sunburned, Windswept, etc.). Each mutation entry specifies its earnings multiplier, visual effect name, roll chance, and which weather types can trigger it. |
| `Config/Sizes.luau` | Defines the size system. Contains the size label thresholds (Tiny/Small/Medium/Large/Massive), the numeric range (0.5 to 3.0), weight calculation formula, and the earnings multiplier curve based on size. |
| `Config/Weather.luau` | Defines the weather event table. Each weather type has a name, duration range, occurrence weight, visual effect name, and which weather mutations it can trigger on brainrots. |
| `Types.luau` | Central type definitions file. Exports Luau type aliases for `BrainrotInstance`, `PlayerData`, `FoodTier`, `MutationData`, `WeatherEvent`, `SizeData`, and any other structured types used across the codebase. Serves as the single source of truth for data shapes. |
| `Utils.luau` | Shared utility functions used by both server and client. Includes helpers for weighted random selection, unique ID generation, number formatting (e.g., "1.2K", "3.4M"), table deep-copy, and time formatting. |

#### src/server/ (ServerScriptService/Server)

| File | Description |
|---|---|
| `init.server.luau` | Server bootstrap script. Runs on game start. Requires and initializes all services in the correct dependency order (see Section 5). Connects `Players.PlayerAdded` and `Players.PlayerRemoving` to DataService lifecycle hooks. This is the single entry point for all server-side logic. |
| `Services/DataService.luau` | Manages all player data using ProfileStore. Loads a player's profile on join, provides `getData(player)` to other services, handles auto-saving, and releases profiles on leave. Defines the default `PlayerData` template (see Section 7). Fires `MoneyUpdated` to the client whenever money changes. |
| `Services/FoodService.luau` | Handles the core "buy food to get a brainrot" loop. Listens for the `BuyFood` remote. Validates the player has enough money, deducts the cost, rolls a brainrot using weighted rarity from the food tier, rolls size, rolls base mutation chance, computes the "stay chance" (the brainrot may run away), and if it stays, adds it to the player's data and fires `BrainrotSpawned` to the client. |
| `Services/BaseService.luau` | Manages each player's plot (base). Assigns a plot to the player on join, tracks current brainrot count vs. capacity, handles the `UpgradeCapacity` remote to increase max capacity (costs money), and fires `CapacityUpdated` to the client. Provides `getPlotPosition(player, slotIndex)` so other services know where to visually place brainrots. |
| `Services/EarningsService.luau` | Runs the passive income loop. Every 1 second, iterates over all online players, sums the `earningsPerSec` of every brainrot in their `ownedBrainrots`, adds that total to their money, and fires `MoneyUpdated` and `EarningsUpdated` to the client. Provides `recalculate(player)` which other services call after any brainrot change (add, remove, mutate). |
| `Services/WeatherService.luau` | (Phase 6) Runs the weather event cycle. Periodically rolls a random weather event (or clear skies), fires `WeatherChanged` to all clients for visual effects, and for each online player's brainrots that lack a weather mutation, rolls a chance to apply the corresponding weather mutation. Calls `EarningsService.recalculate()` after any mutation is applied. |
| `Services/IndexService.luau` | (Phase 7) Manages the collection codex/index. Listens for `RequestIndex` from the client, reads the player's discovered brainrots from their data, and fires `IndexUpdated` back. Provides `registerDiscovery(player, brainrotName, mutation)` called by FoodService when a new brainrot is obtained, updating the index if it is a first-time discovery. |
| `Services/SellService.luau` | (Phase 5) Handles selling brainrots for money. Listens for `SellBrainrot` (sell one) and `SellAll` (sell everything) remotes. Calculates sell value based on the brainrot's rarity, size, and mutations. Removes the brainrot from player data, adds money, and fires updates to the client. |
| `Services/GiftService.luau` | (Phase 7) Handles gifting brainrots between players. Listens for `GiftBrainrot` remote. Validates the sender owns the brainrot and the recipient is online and has base capacity. Transfers the brainrot from sender's data to recipient's data and fires appropriate updates to both clients. |
| `Services/LeaderboardService.luau` | (Phase 7) Manages global leaderboards. Periodically collects stats from online players (total money earned, rarest collection, highest earnings/sec) and updates OrderedDataStores. Provides data for the leaderboard UI via the `RequestLeaderboard` remote. |
| `Remotes/init.luau` | Creates all RemoteEvents and RemoteFunctions under `ReplicatedStorage/Remotes` (a Folder). This module runs before any service so that every service can safely connect to remotes immediately. Returns a table keyed by remote name for easy access: `Remotes.BuyFood`, `Remotes.MoneyUpdated`, etc. |

#### src/client/ (StarterPlayer/StarterPlayerScripts/Client)

| File | Description |
|---|---|
| `init.client.luau` | Client bootstrap script. Runs when the player joins. Requires all UI controllers and calls their `init()` methods. Listens for server-to-client remotes and routes them to the appropriate controller. |
| `Controllers/FoodStoreUI.luau` | Renders the food store GUI. Shows available food tiers, their costs, and rarity odds. Fires `BuyFood` when the player clicks a food item. Listens for `BrainrotSpawned` to show the "you got a brainrot!" reveal animation. |
| `Controllers/MoneyUI.luau` | Displays the player's current money and earnings-per-second on the HUD. Listens for `MoneyUpdated` and `EarningsUpdated` remotes and updates the display with formatted numbers. |
| `Controllers/BaseUI.luau` | Manages the 3D visual representation of the player's base/plot. Places brainrot models at plot positions when `BrainrotSpawned` fires. Shows capacity indicator (e.g., "3/5 brainrots"). Handles the upgrade capacity button and fires `UpgradeCapacity`. Listens for `CapacityUpdated`. |
| `Controllers/IndexUI.luau` | (Phase 7) Renders the collection codex screen. Fires `RequestIndex` on open, receives `IndexUpdated`, and displays all brainrots in a grid -- discovered ones in full color, undiscovered ones as silhouettes. Shows mutation variants (normal, gold, diamond, rainbow) per brainrot. |
| `Controllers/SellUI.luau` | (Phase 5) Renders the sell interface. Shows the player's owned brainrots with their computed sell values. Fires `SellBrainrot` for individual sales or `SellAll` for bulk sales. Updates the display after each sale. |
| `Controllers/WeatherUI.luau` | (Phase 6) Displays weather event notifications and visual effects. Listens for `WeatherChanged` and shows a banner with the current weather type, applies ambient visual effects (rain particles, snow, heat shimmer, etc.), and shows a countdown timer for the event duration. |
| `Controllers/LeaderboardUI.luau` | (Phase 7) Renders the global leaderboard screen. Fires `RequestLeaderboard` on open, receives leaderboard data, and displays ranked player entries with their stats. |
| `Controllers/TutorialUI.luau` | (Phase 8) Runs the first-time-player tutorial sequence. Detects if the player has no brainrots and zero money history, then guides them through buying their first food, understanding their base, and viewing earnings. Marks the tutorial as complete in player data so it does not repeat. |

---

## 3. Rojo Mapping

The `default.project.json` file defines how the filesystem maps to the Roblox DataModel hierarchy. Below is the exact mapping:

```
Filesystem Path                    Roblox DataModel Location
-------------------------------    -------------------------------------------
src/shared/                   -->  ReplicatedStorage.Shared
src/server/                   -->  ServerScriptService.Server
src/client/                   -->  StarterPlayer.StarterPlayerScripts.Client
Packages/                     -->  ReplicatedStorage.Packages
```

### Detailed Breakdown

```
default.project.json
|
+-- DataModel ("Collect Brainrot's")
    |
    +-- ReplicatedStorage
    |   +-- Shared            <-- $path: "src/shared"
    |   |   +-- Config/
    |   |   |   +-- Brainrots      (ModuleScript from Brainrots.luau)
    |   |   |   +-- Foods          (ModuleScript from Foods.luau)
    |   |   |   +-- Mutations      (ModuleScript from Mutations.luau)
    |   |   |   +-- Sizes          (ModuleScript from Sizes.luau)
    |   |   |   +-- Weather        (ModuleScript from Weather.luau)
    |   |   +-- Types              (ModuleScript from Types.luau)
    |   |   +-- Utils              (ModuleScript from Utils.luau)
    |   +-- Packages          <-- $path: "Packages"  (Wally dependencies)
    |   +-- Remotes           (Folder, created at runtime by Remotes/init.luau)
    |
    +-- ServerScriptService
    |   +-- Server            <-- $path: "src/server"
    |       +-- (Script from init.server.luau)
    |       +-- Services/
    |       |   +-- DataService    (ModuleScript)
    |       |   +-- FoodService    (ModuleScript)
    |       |   +-- BaseService    (ModuleScript)
    |       |   +-- EarningsService(ModuleScript)
    |       |   +-- WeatherService (ModuleScript)
    |       |   +-- IndexService   (ModuleScript)
    |       |   +-- SellService    (ModuleScript)
    |       |   +-- GiftService    (ModuleScript)
    |       |   +-- LeaderboardService (ModuleScript)
    |       +-- Remotes/
    |           +-- (ModuleScript from init.luau)
    |
    +-- StarterPlayer
    |   +-- StarterPlayerScripts
    |       +-- Client        <-- $path: "src/client"
    |           +-- (LocalScript from init.client.luau)
    |           +-- Controllers/
    |               +-- FoodStoreUI    (ModuleScript)
    |               +-- MoneyUI        (ModuleScript)
    |               +-- BaseUI         (ModuleScript)
    |               +-- IndexUI        (ModuleScript)
    |               +-- SellUI         (ModuleScript)
    |               +-- WeatherUI      (ModuleScript)
    |               +-- LeaderboardUI  (ModuleScript)
    |               +-- TutorialUI     (ModuleScript)
    |
    +-- Workspace
    |   +-- Baseplate (Part, anchored, 512x20x512 at Y=-10)
    |
    +-- Lighting
    |   (Brightness=2, GlobalShadows=true, Technology=Voxel)
    |
    +-- SoundService
        (RespectFilteringEnabled=true)
```

### How Rojo File Conventions Work

- A file named `init.server.luau` becomes a **Script** (server-side runnable) whose name is the parent folder's name.
- A file named `init.client.luau` becomes a **LocalScript** (client-side runnable) whose name is the parent folder's name.
- A file named `init.luau` becomes a **ModuleScript** whose name is the parent folder's name.
- Any other `.luau` file becomes a **ModuleScript** with the filename (minus extension) as its name.
- Folders on disk become **Folder** instances in the DataModel, unless they contain an `init.*` file, in which case the folder becomes the script itself and other files/folders inside it become children.

---

## 4. Module Dependency Graph

Each arrow (`-->`) means "requires / depends on." All paths are relative to `src/`.

### Server Services

```
init.server.luau
  --> Remotes/init
  --> Services/DataService
  --> Services/BaseService
  --> Services/FoodService
  --> Services/EarningsService
  --> Services/SellService
  --> Services/WeatherService
  --> Services/IndexService
  --> Services/GiftService
  --> Services/LeaderboardService

Remotes/init
  --> (no internal dependencies; creates RemoteEvents/Functions in ReplicatedStorage)

DataService
  --> Packages/ProfileStore
  --> shared/Types

FoodService
  --> shared/Config/Brainrots
  --> shared/Config/Foods
  --> shared/Config/Mutations
  --> shared/Config/Sizes
  --> shared/Types
  --> shared/Utils
  --> Services/DataService
  --> Services/BaseService
  --> Services/EarningsService
  --> Services/IndexService
  --> Remotes/init

BaseService
  --> shared/Types
  --> Services/DataService
  --> Remotes/init

EarningsService
  --> shared/Config/Brainrots
  --> shared/Config/Sizes
  --> shared/Config/Mutations
  --> shared/Types
  --> Services/DataService
  --> Remotes/init

SellService
  --> shared/Config/Brainrots
  --> shared/Config/Sizes
  --> shared/Config/Mutations
  --> shared/Types
  --> Services/DataService
  --> Services/BaseService
  --> Services/EarningsService
  --> Remotes/init

WeatherService
  --> shared/Config/Weather
  --> shared/Config/Mutations
  --> shared/Types
  --> shared/Utils
  --> Services/DataService
  --> Services/EarningsService
  --> Remotes/init

IndexService
  --> shared/Config/Brainrots
  --> shared/Types
  --> Services/DataService
  --> Remotes/init

GiftService
  --> shared/Types
  --> Services/DataService
  --> Services/BaseService
  --> Services/EarningsService
  --> Remotes/init

LeaderboardService
  --> shared/Types
  --> Services/DataService
  --> Remotes/init
```

### Client Controllers

```
init.client.luau
  --> Controllers/FoodStoreUI
  --> Controllers/MoneyUI
  --> Controllers/BaseUI
  --> Controllers/IndexUI
  --> Controllers/SellUI
  --> Controllers/WeatherUI
  --> Controllers/LeaderboardUI
  --> Controllers/TutorialUI

FoodStoreUI
  --> shared/Config/Foods
  --> shared/Config/Brainrots
  --> shared/Utils
  --> Remotes (via ReplicatedStorage)

MoneyUI
  --> shared/Utils
  --> Remotes (via ReplicatedStorage)

BaseUI
  --> shared/Types
  --> shared/Utils
  --> Remotes (via ReplicatedStorage)

IndexUI
  --> shared/Config/Brainrots
  --> shared/Types
  --> Remotes (via ReplicatedStorage)

SellUI
  --> shared/Config/Brainrots
  --> shared/Utils
  --> shared/Types
  --> Remotes (via ReplicatedStorage)

WeatherUI
  --> shared/Config/Weather
  --> Remotes (via ReplicatedStorage)

LeaderboardUI
  --> shared/Utils
  --> Remotes (via ReplicatedStorage)

TutorialUI
  --> shared/Utils
  --> Remotes (via ReplicatedStorage)
```

### Shared Modules (No Internal Dependencies)

```
Config/Brainrots  --> (standalone data table, no dependencies)
Config/Foods      --> (standalone data table, no dependencies)
Config/Mutations  --> (standalone data table, no dependencies)
Config/Sizes      --> (standalone data table, no dependencies)
Config/Weather    --> (standalone data table, no dependencies)
Types             --> (standalone type definitions, no dependencies)
Utils             --> (standalone utility functions, no dependencies)
```

All `Config/` modules and `Types.luau` are pure data/type definitions with zero dependencies. `Utils.luau` is a pure function library with zero dependencies. This keeps the shared layer completely self-contained and importable from anywhere.

---

## 5. Service Boot Order

The server `init.server.luau` loads and initializes services in a strict order. Services that depend on other services must be initialized after their dependencies.

```
Order  Service                 Reason
-----  ----------------------  -----------------------------------------------
  1    Remotes/init            Creates all RemoteEvent/RemoteFunction instances
                               in ReplicatedStorage. Must exist BEFORE any
                               service tries to connect listeners or fire events.

  2    DataService             Loads ProfileStore, sets up PlayerAdded/Removing
                               hooks, defines the default data template. Must be
                               ready before any service calls getData(player).

  3    BaseService             Assigns plots to players, tracks capacity. Must
                               be ready before FoodService checks capacity.

  4    EarningsService         Sets up the 1-second earnings loop. Must be
                               ready before FoodService calls recalculate().

  5    FoodService             Core gameplay loop. Depends on DataService,
                               BaseService, and EarningsService.

  6    SellService             (Phase 5) Depends on DataService, BaseService,
                               and EarningsService.

  7    WeatherService          (Phase 6) Depends on DataService and
                               EarningsService. Starts the weather cycle timer.

  8    IndexService            (Phase 7) Depends on DataService. FoodService
                               calls into IndexService, but IndexService is
                               loaded after -- FoodService holds a lazy
                               reference that resolves after boot.

  9    GiftService             (Phase 7) Depends on DataService, BaseService,
                               and EarningsService.

 10    LeaderboardService      (Phase 7) Depends on DataService. Starts the
                               periodic leaderboard update timer.
```

### Boot Sequence in Pseudocode

```lua
-- init.server.luau
local Remotes = require(script.Remotes)             -- 1. Create all remotes

local DataService = require(script.Services.DataService)
DataService.init()                                    -- 2. Set up ProfileStore

local BaseService = require(script.Services.BaseService)
BaseService.init()                                    -- 3. Set up plot system

local EarningsService = require(script.Services.EarningsService)
EarningsService.init()                                -- 4. Start earnings loop

local FoodService = require(script.Services.FoodService)
FoodService.init()                                    -- 5. Connect BuyFood remote

local SellService = require(script.Services.SellService)
SellService.init()                                    -- 6. Connect sell remotes

local WeatherService = require(script.Services.WeatherService)
WeatherService.init()                                 -- 7. Start weather cycle

local IndexService = require(script.Services.IndexService)
IndexService.init()                                   -- 8. Connect index remotes

local GiftService = require(script.Services.GiftService)
GiftService.init()                                    -- 9. Connect gift remote

local LeaderboardService = require(script.Services.LeaderboardService)
LeaderboardService.init()                             -- 10. Start leaderboard timer

-- Connect player lifecycle
Players.PlayerAdded:Connect(function(player)
    DataService.onPlayerAdded(player)
    BaseService.onPlayerAdded(player)
end)

Players.PlayerRemoving:Connect(function(player)
    DataService.onPlayerRemoving(player)
    BaseService.onPlayerRemoving(player)
end)
```

---

## 6. RemoteEvent/RemoteFunction Contracts

All remotes are created by `Remotes/init.luau` as children of `ReplicatedStorage/Remotes`.

Direction legend:
- **C->S** = Client fires, Server listens (RemoteEvent:FireServer or RemoteFunction:InvokeServer)
- **S->C** = Server fires, Client listens (RemoteEvent:FireClient)

### Complete Remote Registry

| # | Remote Name | Type | Direction | Payload | Phase | Used By (Server) | Used By (Client) |
|---|---|---|---|---|---|---|---|
| 1 | `BuyFood` | RemoteEvent | C->S | `{ foodTier: string }` | Phase 1 | FoodService | FoodStoreUI |
| 2 | `BrainrotSpawned` | RemoteEvent | S->C | `{ brainrotData: BrainrotInstance }` | Phase 1 | FoodService | FoodStoreUI, BaseUI |
| 3 | `BrainrotRanAway` | RemoteEvent | S->C | `{ brainrotName: string, rarity: string }` | Phase 1 | FoodService | FoodStoreUI |
| 4 | `MoneyUpdated` | RemoteEvent | S->C | `{ money: number }` | Phase 1 | DataService, EarningsService | MoneyUI |
| 5 | `EarningsUpdated` | RemoteEvent | S->C | `{ earningsPerSec: number }` | Phase 1 | EarningsService | MoneyUI |
| 6 | `UpgradeCapacity` | RemoteEvent | C->S | `{}` (no payload) | Phase 1 | BaseService | BaseUI |
| 7 | `CapacityUpdated` | RemoteEvent | S->C | `{ current: number, max: number }` | Phase 1 | BaseService | BaseUI |
| 8 | `SellBrainrot` | RemoteEvent | C->S | `{ brainrotId: string }` | Phase 5 | SellService | SellUI |
| 9 | `SellAll` | RemoteEvent | C->S | `{}` (no payload) | Phase 5 | SellService | SellUI |
| 10 | `SellConfirmed` | RemoteEvent | S->C | `{ soldCount: number, totalValue: number }` | Phase 5 | SellService | SellUI |
| 11 | `WeatherChanged` | RemoteEvent | S->C | `{ weatherType: string, duration: number }` | Phase 6 | WeatherService | WeatherUI |
| 12 | `BrainrotMutated` | RemoteEvent | S->C | `{ brainrotId: string, weatherMutation: string }` | Phase 6 | WeatherService | BaseUI |
| 13 | `RequestIndex` | RemoteFunction | C->S | `{}` (no payload) | Phase 7 | IndexService | IndexUI |
| 14 | `IndexUpdated` | RemoteEvent | S->C | `{ indexData: IndexData }` | Phase 7 | IndexService | IndexUI |
| 15 | `GiftBrainrot` | RemoteEvent | C->S | `{ brainrotId: string, targetPlayerId: number }` | Phase 7 | GiftService | BaseUI |
| 16 | `GiftReceived` | RemoteEvent | S->C | `{ brainrotData: BrainrotInstance, fromPlayerName: string }` | Phase 7 | GiftService | BaseUI |
| 17 | `FuseBrainrots` | RemoteEvent | C->S | `{ brainrotName: string }` | Phase 8 | FoodService | BaseUI |
| 18 | `FuseResult` | RemoteEvent | S->C | `{ success: boolean, newBrainrot: BrainrotInstance? }` | Phase 8 | FoodService | BaseUI |
| 19 | `RequestLeaderboard` | RemoteFunction | C->S | `{}` (no payload) | Phase 7 | LeaderboardService | LeaderboardUI |
| 20 | `InitialData` | RemoteEvent | S->C | `{ money: number, earningsPerSec: number, capacity: { current: number, max: number }, brainrots: {BrainrotInstance} }` | Phase 1 | DataService | MoneyUI, BaseUI |
| 21 | `TutorialComplete` | RemoteEvent | C->S | `{}` (no payload) | Phase 8 | DataService | TutorialUI |

### Payload Type Definitions

```lua
-- BrainrotInstance (see Section 8 for full definition)
-- IndexData shape:
type IndexData = {
    normal: {string},      -- list of discovered brainrot names (normal variant)
    gold: {string},        -- list of discovered brainrot names (gold variant)
    diamond: {string},     -- list of discovered brainrot names (diamond variant)
    rainbow: {string},     -- list of discovered brainrot names (rainbow variant)
}
```

### Security Notes

- All C->S remotes are validated server-side. The server never trusts client-supplied data.
- Money amounts, brainrot ownership, and capacity checks are always re-verified on the server before any mutation.
- Rate limiting should be applied to `BuyFood`, `SellBrainrot`, `SellAll`, `GiftBrainrot`, and `FuseBrainrots` to prevent spam.

---

## 7. PlayerData Schema

ProfileStore stores the following data per player. The schema grows across phases.

```lua
type PlayerData = {
    -- Phase 1: Core
    money: number,                         -- Current in-game currency balance (starts at 100)
    ownedBrainrots: {BrainrotInstance},     -- Array of brainrots currently on the player's base
    baseCapacity: number,                   -- Max brainrots the base can hold (starts at 1)

    -- Phase 5: Sell system stats
    totalMoneyEarned: number,              -- Lifetime money earned (never decreases, used for leaderboards)

    -- Phase 7: Collection & social
    totalTimePlayed: number,               -- Total seconds played across all sessions
    totalRobuxSpent: number,               -- Lifetime Robux spent (for potential analytics)
    index: {                               -- Collection codex tracking
        normal: {string},                  -- Brainrot names discovered in normal variant
        gold: {string},                    -- Brainrot names discovered in Gold mutation
        diamond: {string},                 -- Brainrot names discovered in Diamond mutation
        rainbow: {string},                 -- Brainrot names discovered in Rainbow mutation
    },
    unlockedFences: {string},              -- IDs of unlocked decorative fences for base

    -- Phase 8: Personality & tutorial
    tutorialComplete: boolean,             -- Whether the player has finished the tutorial
}
```

### Default Template

When a new player joins for the first time, ProfileStore creates their profile from this default template:

```lua
local DEFAULT_DATA: PlayerData = {
    money = 100,
    ownedBrainrots = {},
    baseCapacity = 1,
    totalMoneyEarned = 0,
    totalTimePlayed = 0,
    totalRobuxSpent = 0,
    index = {
        normal = {},
        gold = {},
        diamond = {},
        rainbow = {},
    },
    unlockedFences = {},
    tutorialComplete = false,
}
```

### Schema Migration Notes

ProfileStore supports data reconciliation: if a new field is added to the default template, existing player profiles automatically receive the default value for that field on next load. This means phases can safely add new fields without writing migration logic.

---

## 8. BrainrotInstance Type

A `BrainrotInstance` represents a single brainrot that lives on a player's base. This is the most important data structure in the game.

```lua
type BrainrotInstance = {
    -- Phase 1: Core fields
    id: string,                  -- Unique identifier (generated via HttpService:GenerateGUID)
    name: string,                -- Display name, e.g. "Tralalero Tralala"
    rarity: string,              -- Rarity tier: "Common" | "Uncommon" | "Rare" | "Epic"
                                 --   | "Legendary" | "Mythic" | "Secret"
    baseMutation: string?,       -- Base mutation rolled at spawn: "Gold" | "Diamond"
                                 --   | "Rainbow" | nil (most brainrots have nil)
    size: number,                -- Scale factor from 0.5 to 3.0 (continuous)
    sizeLabel: string,           -- Human-readable size: "Tiny" | "Small" | "Medium"
                                 --   | "Large" | "Massive"
    weight: number,              -- Weight in lbs, derived from size via formula
    earningsPerSec: number,      -- Computed passive income per second (see formula below)

    -- Phase 6: Weather mutations
    weatherMutation: string?,    -- Weather mutation: "Soaked" | "Frozen" | "Sunburned"
                                 --   | "Windswept" | nil (applied by WeatherService)

    -- Phase 8: Personality system
    personality: string?,        -- Personality trait: "Lazy" | "Hyper" | "Chill"
                                 --   | "Grumpy" | nil (rolled at spawn in Phase 8+)
}
```

### Earnings Formula

The `earningsPerSec` field is computed (not stored as a fixed value) using this formula:

```
earningsPerSec = baseEarnings
               * sizeMult(size)
               * baseMutationMult(baseMutation)
               * weatherMutationMult(weatherMutation)
               * personalityMult(personality)
```

Where:
- `baseEarnings` comes from `Config/Brainrots` (varies by rarity)
- `sizeMult` comes from `Config/Sizes` (larger = higher multiplier)
- `baseMutationMult` comes from `Config/Mutations` (Gold=2x, Diamond=5x, Rainbow=10x, nil=1x)
- `weatherMutationMult` comes from `Config/Mutations` (varies by weather mutation, nil=1x)
- `personalityMult` is phase 8 (Hyper=1.2x, Chill=1.0x, Lazy=0.8x, Grumpy=0.9x, nil=1x)

`EarningsService.recalculate(player)` recomputes this for every brainrot whenever their data changes.

---

## 9. How Phases Plug In

The codebase follows the **open/closed principle**: new phases add new files and extend config tables without modifying existing service logic (in most cases).

### The Modular Pattern

1. **Config modules are append-only.** Adding a new brainrot means adding an entry to `Config/Brainrots.luau`. Adding a new food tier means adding an entry to `Config/Foods.luau`. Existing entries are never modified.

2. **Services are self-contained modules.** Each service exposes an `init()` function and optionally `onPlayerAdded(player)` / `onPlayerRemoving(player)` lifecycle hooks. The server bootstrap (`init.server.luau`) simply requires and inits each service in order.

3. **New phases add new services to the boot list.** For example, Phase 5 adds `SellService`. The only change to `init.server.luau` is adding two lines:
   ```lua
   local SellService = require(script.Services.SellService)
   SellService.init()
   ```

4. **New phases add new remotes to the registry.** `Remotes/init.luau` contains a flat list of remote names and types. Adding a new remote is a single table entry.

5. **New phases add new client controllers.** The client bootstrap loads controllers the same way the server loads services -- just add to the list.

6. **PlayerData grows via schema reconciliation.** New fields are added to the default template in `DataService`. ProfileStore automatically fills in defaults for existing players.

### Phase-to-File Mapping

| Phase | New Files Added | Existing Files Modified |
|---|---|---|
| Phase 0 | Project scaffolding: `default.project.json`, `wally.toml`, `aftman.toml`, all docs | N/A (initial setup) |
| Phase 1 | `Config/Brainrots`, `Config/Foods`, `Config/Mutations`, `Config/Sizes`, `Types`, `Utils`, `DataService`, `FoodService`, `BaseService`, `EarningsService`, `Remotes/init`, `FoodStoreUI`, `MoneyUI`, `BaseUI` | `init.server.luau`, `init.client.luau` |
| Phase 2 | (3D models, visual polish) | Potentially `BaseUI` for model placement |
| Phase 3 | (Map building in Studio) | `default.project.json` if map parts are synced |
| Phase 4 | (Sound effects, animations) | Various UI controllers for SFX hooks |
| Phase 5 | `SellService`, `SellUI` | `init.server.luau` (add SellService to boot), `init.client.luau` (add SellUI), `Remotes/init` (add sell remotes) |
| Phase 6 | `Config/Weather`, `WeatherService`, `WeatherUI` | `init.server.luau` (add WeatherService to boot), `init.client.luau` (add WeatherUI), `Remotes/init` (add weather remotes) |
| Phase 7 | `IndexService`, `GiftService`, `LeaderboardService`, `IndexUI`, `LeaderboardUI` | `init.server.luau` (add 3 services to boot), `init.client.luau` (add 3 controllers), `Remotes/init` (add remotes), `DataService` (add index/fence fields to template), `FoodService` (call IndexService on discovery) |
| Phase 8 | `TutorialUI` | `Config/Brainrots` (add personality data), `FoodService` (roll personality), `Types` (add personality to BrainrotInstance), `DataService` (add tutorialComplete field), `init.client.luau` (add TutorialUI) |
| Phase 9 | (Gamepass/DevProduct configs) | `FoodService` (luck boosts), `BaseService` (capacity boosts), various services for Robux-related features |

### Cross-Service Communication Pattern

Services communicate through two mechanisms:

1. **Direct function calls** -- One service requires another and calls its public functions. Example: `FoodService` calls `DataService.getData(player)` and `EarningsService.recalculate(player)`.

2. **RemoteEvents** -- For server-to-client communication. Services fire remotes; client controllers listen. The server never listens to other services via remotes (that would be an anti-pattern).

Services do NOT use BindableEvents or other indirect server-side messaging. Direct `require()` calls keep the dependency graph explicit and traceable.

---

## 10. Data Flow Diagrams

### 10.1 Buying Food (Core Loop)

This is the most important flow in the game. It is the primary way players acquire brainrots.

```
Player clicks "Buy [Food Tier]" in FoodStoreUI
    |
    v
Client fires BuyFood remote --> { foodTier = "Tier 2" }
    |
    v
[SERVER] FoodService.onBuyFood(player, data)
    |
    +-- 1. Validate: DataService.getData(player) exists
    +-- 2. Validate: player.money >= Foods[data.foodTier].cost
    +-- 3. Validate: #player.ownedBrainrots < player.baseCapacity
    |       (if full, reject with error message)
    +-- 4. Deduct money: data.money -= Foods[data.foodTier].cost
    +-- 5. Fire MoneyUpdated to client: { money = data.money }
    |
    +-- 6. ROLL BRAINROT:
    |       a. Roll rarity using weighted random from food tier's rarity weights
    |       b. Pick random brainrot of that rarity from Config/Brainrots
    |       c. Roll size (0.5 to 3.0, weighted toward center)
    |       d. Compute sizeLabel and weight from Config/Sizes
    |       e. Roll base mutation chance:
    |           - Gold:    1 in 100  (1%)
    |           - Diamond: 1 in 1000 (0.1%)
    |           - Rainbow: 1 in 10000 (0.01%)
    |           - None:    remaining probability
    |       f. Compute earningsPerSec from formula
    |       g. Generate unique id via HttpService:GenerateGUID()
    |       h. Construct BrainrotInstance table
    |
    +-- 7. STAY CHANCE:
    |       Roll whether the brainrot "stays" at the base.
    |       Common=95%, Uncommon=90%, Rare=80%, Epic=70%,
    |       Legendary=60%, Mythic=50%, Secret=40%
    |       |
    |       +-- If STAYS:
    |       |       a. Append BrainrotInstance to data.ownedBrainrots
    |       |       b. IndexService.registerDiscovery(player, name, mutation)
    |       |       c. EarningsService.recalculate(player)
    |       |       d. Fire BrainrotSpawned to client: { brainrotData }
    |       |       e. Fire CapacityUpdated to client
    |       |
    |       +-- If RUNS AWAY:
    |               a. Fire BrainrotRanAway to client: { name, rarity }
    |               b. (Player sees the brainrot but it escapes -- tension moment)
    v
[CLIENT] FoodStoreUI receives BrainrotSpawned or BrainrotRanAway
    |
    +-- BrainrotSpawned: Show reveal animation, pass to BaseUI for 3D placement
    +-- BrainrotRanAway: Show "it ran away!" animation
```

### 10.2 Earnings Tick (Passive Income)

```
[SERVER] EarningsService -- runs every 1 second via a while loop with task.wait(1)
    |
    +-- For each online player with loaded data:
        |
        +-- 1. total = 0
        +-- 2. For each brainrot in player.ownedBrainrots:
        |       total += brainrot.earningsPerSec
        |
        +-- 3. player.data.money += total
        +-- 4. player.data.totalMoneyEarned += total
        |
        +-- 5. Fire MoneyUpdated to player: { money = player.data.money }
        +-- 6. Fire EarningsUpdated to player: { earningsPerSec = total }
            |
            v
[CLIENT] MoneyUI receives MoneyUpdated
    |
    +-- Update money display with formatted number
    +-- Update earnings/sec display
```

### 10.3 Weather Event Cycle

```
[SERVER] WeatherService -- runs on a timer (every 120-300 seconds)
    |
    +-- 1. Roll random weather type from Config/Weather (weighted)
    |       OR roll "Clear" (no weather, ~30% chance)
    |
    +-- 2. Determine duration (60-180 seconds depending on weather type)
    |
    +-- 3. Fire WeatherChanged to ALL clients:
    |       { weatherType = "Rain", duration = 120 }
    |       |
    |       v
    |   [CLIENT] WeatherUI receives WeatherChanged
    |       +-- Show weather banner notification
    |       +-- Start ambient visual effects (particles, lighting changes)
    |       +-- Show countdown timer
    |
    +-- 4. For each online player:
        |
        +-- For each brainrot in player.ownedBrainrots:
            |
            +-- IF brainrot.weatherMutation == nil:
                |
                +-- Roll mutation chance (varies by weather type, ~5-15%)
                |
                +-- IF mutation triggers:
                    |
                    +-- a. Set brainrot.weatherMutation = corresponding mutation
                    +-- b. Recompute brainrot.earningsPerSec
                    +-- c. EarningsService.recalculate(player)
                    +-- d. Fire BrainrotMutated to player:
                            { brainrotId, weatherMutation }
                            |
                            v
                    [CLIENT] BaseUI receives BrainrotMutated
                        +-- Apply visual mutation effect to 3D brainrot model
```

### 10.4 Selling Brainrots

```
Player clicks "Sell" on a brainrot in SellUI
    |
    v
Client fires SellBrainrot remote --> { brainrotId = "abc-123" }
    |
    v
[SERVER] SellService.onSellBrainrot(player, data)
    |
    +-- 1. Validate: DataService.getData(player) exists
    +-- 2. Find brainrot with matching id in ownedBrainrots
    +-- 3. If not found, reject
    +-- 4. Calculate sell value:
    |       sellValue = baseSellValue(rarity) * sizeMult * mutationMult
    +-- 5. Remove brainrot from ownedBrainrots
    +-- 6. Add sellValue to player.data.money
    +-- 7. EarningsService.recalculate(player)
    +-- 8. Fire MoneyUpdated to client
    +-- 9. Fire CapacityUpdated to client
    +-- 10. Fire SellConfirmed to client: { soldCount = 1, totalValue = sellValue }
```

### 10.5 Sell All

```
Player clicks "Sell All" in SellUI
    |
    v
Client fires SellAll remote --> {}
    |
    v
[SERVER] SellService.onSellAll(player)
    |
    +-- 1. Validate: DataService.getData(player) exists
    +-- 2. totalValue = 0, soldCount = 0
    +-- 3. For each brainrot in ownedBrainrots:
    |       totalValue += calculateSellValue(brainrot)
    |       soldCount += 1
    +-- 4. Clear ownedBrainrots to empty array
    +-- 5. Add totalValue to player.data.money
    +-- 6. EarningsService.recalculate(player)
    +-- 7. Fire MoneyUpdated, CapacityUpdated, SellConfirmed to client
```

### 10.6 Upgrading Base Capacity

```
Player clicks "Upgrade Capacity" in BaseUI
    |
    v
Client fires UpgradeCapacity remote --> {}
    |
    v
[SERVER] BaseService.onUpgradeCapacity(player)
    |
    +-- 1. Get current capacity from player data
    +-- 2. Calculate upgrade cost (exponential: baseCost * 2^(currentCap - 1))
    +-- 3. Validate player has enough money
    +-- 4. Deduct cost from money
    +-- 5. Increment baseCapacity by 1
    +-- 6. Fire MoneyUpdated to client
    +-- 7. Fire CapacityUpdated to client: { current = #brainrots, max = newCap }
```

### 10.7 Gifting a Brainrot

```
Player selects a brainrot and clicks "Gift to [Player]"
    |
    v
Client fires GiftBrainrot remote --> { brainrotId = "abc-123", targetPlayerId = 456 }
    |
    v
[SERVER] GiftService.onGiftBrainrot(sender, data)
    |
    +-- 1. Validate: sender owns brainrot with that id
    +-- 2. Validate: target player is online and has loaded data
    +-- 3. Validate: target player's #ownedBrainrots < baseCapacity
    +-- 4. Remove brainrot from sender.ownedBrainrots
    +-- 5. Append brainrot to target.ownedBrainrots
    +-- 6. EarningsService.recalculate(sender)
    +-- 7. EarningsService.recalculate(target)
    +-- 8. Fire CapacityUpdated to sender
    +-- 9. Fire CapacityUpdated to target
    +-- 10. Fire GiftReceived to target:
            { brainrotData = brainrot, fromPlayerName = sender.Name }
    +-- 11. IndexService.registerDiscovery(target, brainrot.name, brainrot.baseMutation)
```

### 10.8 Fusing Brainrots

```
Player selects 3 brainrots of the same name and clicks "Fuse"
    |
    v
Client fires FuseBrainrots remote --> { brainrotName = "Tralalero Tralala" }
    |
    v
[SERVER] FoodService.onFuseBrainrots(player, data)
    |
    +-- 1. Find all brainrots in ownedBrainrots matching data.brainrotName
    +-- 2. Validate: at least 3 exist
    +-- 3. Remove the first 3 matching brainrots
    +-- 4. Roll a new brainrot of the NEXT rarity tier:
    |       (Common->Uncommon, Uncommon->Rare, etc.)
    +-- 5. Roll size, base mutation, personality for the new brainrot
    +-- 6. Add new brainrot to ownedBrainrots
    +-- 7. EarningsService.recalculate(player)
    +-- 8. IndexService.registerDiscovery(player, newBrainrot.name, newBrainrot.baseMutation)
    +-- 9. Fire FuseResult to client: { success = true, newBrainrot = brainrotData }
    +-- 10. Fire CapacityUpdated to client (count changed: -3 + 1 = -2)
```

### 10.9 Player Join / Initial Data Load

```
Player connects to game server
    |
    v
[SERVER] Players.PlayerAdded fires
    |
    +-- DataService.onPlayerAdded(player):
    |       1. ProfileStore:LoadProfileAsync(player.UserId)
    |       2. If profile fails to load, kick player
    |       3. Reconcile profile data with default template (fills new fields)
    |       4. Store profile in active profiles table
    |       5. Fire InitialData to client: { money, earningsPerSec, capacity, brainrots }
    |
    +-- BaseService.onPlayerAdded(player):
            1. Assign an available plot to the player
            2. Mark plot as occupied
            3. Store player-to-plot mapping

[CLIENT] init.client.luau runs
    |
    +-- Require all controllers, call init()
    +-- Wait for InitialData remote
    +-- Route initial data to MoneyUI, BaseUI
    +-- BaseUI places existing brainrot models in the plot
```

### 10.10 Player Leave / Data Save

```
Player disconnects
    |
    v
[SERVER] Players.PlayerRemoving fires
    |
    +-- BaseService.onPlayerRemoving(player):
    |       1. Free the plot assignment
    |       2. Clean up any 3D models in the plot
    |
    +-- DataService.onPlayerRemoving(player):
            1. Update totalTimePlayed with session duration
            2. ProfileStore:Release() -- saves and unlocks the profile
            3. Remove from active profiles table
```

---

## Appendix A: Naming Conventions

| Context | Convention | Example |
|---|---|---|
| Files | PascalCase.luau | `FoodService.luau` |
| Modules | PascalCase | `local FoodService = {}` |
| Functions | camelCase | `function FoodService.getData()` |
| Constants | UPPER_SNAKE | `local MAX_CAPACITY = 50` |
| Types | PascalCase | `type BrainrotInstance = { ... }` |
| RemoteEvents | PascalCase | `BuyFood`, `MoneyUpdated` |
| Config keys | camelCase | `{ baseCost = 100, rarityWeights = ... }` |

## Appendix B: Error Handling Pattern

All services follow a consistent error handling pattern:

1. **Validate inputs** at the top of every remote handler. Return early (with an optional error remote to the client) if validation fails.
2. **Never trust client data.** All monetary amounts, brainrot ownership, and capacity are verified server-side.
3. **Wrap DataStore operations** in pcall. ProfileStore handles retries internally, but the service should handle the case where a profile is not loaded.
4. **Log warnings** via `warn()` for unexpected states (brainrot not found, player data not loaded, etc.) to aid debugging.

## Appendix C: Performance Considerations

1. **EarningsService loop** iterates all online players every second. For large servers (50+ players with 50+ brainrots each), this could involve thousands of calculations. Keep the earnings formula simple and avoid table allocations in the hot loop.
2. **WeatherService mutations** only process brainrots that lack a weather mutation (`weatherMutation == nil`), reducing unnecessary work.
3. **RemoteEvent batching** -- `MoneyUpdated` fires frequently (every second). Consider batching or throttling updates if client UI cannot keep up.
4. **LeaderboardService** uses a longer update interval (every 60 seconds) to avoid excessive DataStore writes to OrderedDataStores.
